// #include <iostream>


// // #[inline(always)]
// //     pub fn cells(&self) -> [(i32, i32); 4] {
// //         macro_rules! gen_cells {
// //             ($([$(($x:expr, $y:expr)),*]),*) => {
// //                 [$(
// //                     [$(($x, $y)),*],   // North
// //                     [$((-$x, -$y)),*], // South
// //                     [$(($y, -$x)),*],  // East
// //                     [$((-$y, $x)),*]   // West
// //                 ),*]
// //             };
// //         }
// //         const CELLS: &'static [[(i32, i32); 4]] = &gen_cells![
// //             [(-1, 0), (0, 0), (1, 0), (2, 0)],  // I
// //             [(0, 0), (1, 0), (0, 1), (1, 1)],   // O
// //             [(-1, 0), (0, 0), (1, 0), (0, 1)],  // T
// //             [(-1, 0), (0, 0), (1, 0), (1, 1)],  // L
// //             [(-1, 0), (0, 0), (1, 0), (-1, 1)], // J
// //             [(-1, 0), (0, 0), (0, 1), (1, 1)],  // S
// //             [(-1, 1), (0, 1), (0, 0), (1, 0)]   // Z
// //         ];
// //         let index = self.0 as usize * 4 + self.1 as usize;
// //         CELLS[index]
// //     }
    
// /*
// pub fn rotation_points(&self) -> [(i32, i32); 5] {
//         use Piece::*;
//         use RotationState::*;
//         match (self.0, self.1) {
//             (O, North) => [(0, 0); 5],
//             (O, East) => [(0, -1); 5],
//             (O, South) => [(-1, -1); 5],
//             (O, West) => [(-1, 0); 5],

//             (I, North) => [(0, 0), (-1, 0), (2, 0), (-1, 0), (2, 0)],
//             (I, East) => [(-1, 0), (0, 0), (0, 0), (0, 1), (0, -2)],
//             (I, South) => [(-1, 1), (1, 1), (-2, 1), (1, 0), (-2, 0)],
//             (I, West) => [(0, 1), (0, 1), (0, 1), (0, -1), (0, 2)],

//             // The rotation points for T, L, J, S, Z are all the same.
//             (_, North) => [(0, 0); 5],
//             (_, East) => [(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
//             (_, South) => [(0, 0); 5],
//             (_, West) => [(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
//         }
//     }
//  */


// // [i][j][k] = piece i, rotation j, offset k
// const int piece_offsets[7][4][4][2] = {
//     { //I
//         { {-1, 0}, {0, 0}, {1, 0}, {2, 0} }, // NORTH
//         { {0, 1}, {0, 0}, {0, -1}, {0, -2} }, // EAST
//         { {1, 0}, {0, 0}, {-1, 0}, {-2, 0} }, // SOUTH
//         { {0, -1}, {0, 0}, {0, 1}, {0, 2} } // WEST
//     },
//     { //T
//         { {-1, 0}, {0, 0}, {1, 0}, {0, 1} }, // NORTH
//         { {0, 1}, {0, 0}, {0, -1}, {-1, 0} }, // EAST
//         { {1, 0}, {0, 0}, {-1, 0}, {0, -1} }, // SOUTH
//         { {0, -1}, {0, 0}, {0, 1}, {1, 0} } // WEST
//     },
//     { //O
//         { {0, 0}, {1, 0}, {0, 1}, {1, 1} }, // NORTH
//         { {0, 0}, {1, 0}, {0, 1}, {1, 1} }, // EAST
//         { {0, 0}, {1, 0}, {0, 1}, {1, 1} }, // SOUTH
//         { {0, 0}, {1, 0}, {0, 1}, {1, 1} } // WEST
//     },
//     { //L
//         { {-1, 0}, {0, 0}, {1, 0}, {1, 1} }, // NORTH
//         { {0, 1}, {0, 0}, {0, -1}, {-1, -1} }, // EAST
//         { {1, 0}, {0, 0}, {-1, 0}, {1, -1} }, // SOUTH
//         { {0, -1}, {0, 0}, {0, 1}, {-1, 1} } // WEST
//     },
//     { //J
//         { {-1, 0}, {0, 0}, {1, 0}, {1, -1} }, // NORTH
//         { {0, 1}, {0, 0}, {0, -1}, {1, 1} }, // EAST
//         { {1, 0}, {0, 0}, {-1, 0}, {-1, 1} }, // SOUTH
//         { {0, -1}, {0, 0}, {0, 1}, {-1, -1} } // WEST
//     },
//     { //S
//         { {-1, 0}, {0, 0}, {0, 1}, {1, 1} }, // NORTH
//         { {0, 1}, {0, 0}, {1, 0}, {1, -1} }, // EAST
//         { {1, 0}, {0, 0}, {1, -1}, {0, 1} }, // SOUTH
//         { {0, -1}, {0, 0}, {-1, 0}, {-1, 1} } // WEST
//     },
//     { //Z
//         { {-1, 1}, {0, 1}, {0, 0}, {1, 0} }, // NORTH
//         { {1, 1}, {1, 0}, {0, 0}, {0, -1} }, // EAST
//         { {1, -1}, {0, -1}, {0, 0}, {-1, 0} }, // SOUTH
//         { {-1, -1}, {-1, 0}, {0, 0}, {0, 1} } // WEST
//     }
// };

// const int kick_rules[7][4][5][2] = {
//     { //I
//         { {0, 0}, {-1, 0}, {2, 0}, {-1, 0}, {2, 0} }, // NORTH
//         { {0, 0}, {-1, 0}, {2, 0}, {-1, 0}, {2, 0} }, // EAST
//         { {0, 0}, {2, 0}, {-1, 0}, {2, 0}, {-1, 0} }, // SOUTH
//         { {0, 0}, {2, 0}, {-1, 0}, {2, 0}, {-1, 0} } // WEST
//     },
//     { //T
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} }, // NORTH
//         { {0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2} }, // EAST
//         { {0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2} }, // SOUTH
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} } // WEST
//     },
//     { //O
//         { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} }, // NORTH
//         { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} }, // EAST
//         { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} }, // SOUTH
//         { {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0} } // WEST
//     },
//     { //L
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // NORTH
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} }, // EAST
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // SOUTH
//         { {0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2} } // WEST
//     },
//     { //J
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} }, // NORTH
//         { {0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2} }, // EAST
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // SOUTH
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} } // WEST
//     },
//     { //S
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // NORTH
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, 2}, {-1, 2} }, // EAST
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // SOUTH
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} } // WEST
//     },
//     { //Z
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} }, // NORTH
//         { {0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2} }, // EAST
//         { {0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2} }, // SOUTH
//         { {0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2} } // WEST
//     }
// };





// class PIECE{
//     public:
//         int x, y;
//         int shape_num, r;
//         int* shape_dat[4][4][2];
//         int* shape[4][2];
//         int* kick[5][2];

//         PIECE(){
//             x = 0;
//             y = 0;
//             shape_num = -1;
//             r = 0;
//             for(int i = 0; i < 4; i++){
//                 for(int j = 0; j < 4; j++){
//                     shape_dat[i][j][0] = 0;
//                     shape_dat[i][j][1] = 0;
//                 }
//             }
//             for(int i = 0; i < 4; i++){
//                 shape[i][0] = 0;
//                 shape[i][1] = 0;
//             }
//             for(int i = 0; i < 5; i++){
//                 kick[i][0] = 0;
//                 kick[i][1] = 0;
//             }
//         }

//         PIECE(int shape_num, int x, int y, int r){
//             this->x = x;
//             this->y = y;
//             this->shape_num = shape_num;
//             this->r = r;
//             this->shape_dat = piece_offsets[shape_num];
//             this->shape = &shape_dat[r];

//         }

// };






